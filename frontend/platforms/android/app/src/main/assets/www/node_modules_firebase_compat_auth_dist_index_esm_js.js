(self["webpackChunkfrontend"] = self["webpackChunkfrontend"] || []).push([["node_modules_firebase_compat_auth_dist_index_esm_js"],{

/***/ 1623:
/*!******************************************************************!*\
  !*** ./node_modules/@firebase/auth-compat/dist/index.esm2017.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _firebase_app_compat__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @firebase/app-compat */ 50156);
/* harmony import */ var _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @firebase/auth/internal */ 58098);
/* harmony import */ var _firebase_component__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @firebase/component */ 28604);
/* harmony import */ var _firebase_util__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @firebase/util */ 33854);





var name = "@firebase/auth-compat";
var version = "0.2.9";

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const CORDOVA_ONDEVICEREADY_TIMEOUT_MS = 1000;
function _getCurrentScheme() {
    var _a;
    return ((_a = self === null || self === void 0 ? void 0 : self.location) === null || _a === void 0 ? void 0 : _a.protocol) || null;
}
/**
 * @return {boolean} Whether the current environment is http or https.
 */
function _isHttpOrHttps() {
    return _getCurrentScheme() === 'http:' || _getCurrentScheme() === 'https:';
}
/**
 * @param {?string=} ua The user agent.
 * @return {boolean} Whether the app is rendered in a mobile iOS or Android
 *     Cordova environment.
 */
function _isAndroidOrIosCordovaScheme(ua = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_3__.getUA)()) {
    return !!((_getCurrentScheme() === 'file:' || _getCurrentScheme() === 'ionic:') &&
        ua.toLowerCase().match(/iphone|ipad|ipod|android/));
}
/**
 * @return {boolean} Whether the environment is a native environment, where
 *     CORS checks do not apply.
 */
function _isNativeEnvironment() {
    return (0,_firebase_util__WEBPACK_IMPORTED_MODULE_3__.isReactNative)() || (0,_firebase_util__WEBPACK_IMPORTED_MODULE_3__.isNode)();
}
/**
 * Checks whether the user agent is IE11.
 * @return {boolean} True if it is IE11.
 */
function _isIe11() {
    return (0,_firebase_util__WEBPACK_IMPORTED_MODULE_3__.isIE)() && (document === null || document === void 0 ? void 0 : document.documentMode) === 11;
}
/**
 * Checks whether the user agent is Edge.
 * @param {string} userAgent The browser user agent string.
 * @return {boolean} True if it is Edge.
 */
function _isEdge(ua = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_3__.getUA)()) {
    return /Edge\/\d+/.test(ua);
}
/**
 * @param {?string=} opt_userAgent The navigator user agent.
 * @return {boolean} Whether local storage is not synchronized between an iframe
 *     and a popup of the same domain.
 */
function _isLocalStorageNotSynchronized(ua = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_3__.getUA)()) {
    return _isIe11() || _isEdge(ua);
}
/** @return {boolean} Whether web storage is supported. */
function _isWebStorageSupported() {
    try {
        const storage = self.localStorage;
        const key = _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__._generateEventId();
        if (storage) {
            // setItem will throw an exception if we cannot access WebStorage (e.g.,
            // Safari in private mode).
            storage['setItem'](key, '1');
            storage['removeItem'](key);
            // For browsers where iframe web storage does not synchronize with a popup
            // of the same domain, indexedDB is used for persistent storage. These
            // browsers include IE11 and Edge.
            // Make sure it is supported (IE11 and Edge private mode does not support
            // that).
            if (_isLocalStorageNotSynchronized()) {
                // In such browsers, if indexedDB is not supported, an iframe cannot be
                // notified of the popup sign in result.
                return (0,_firebase_util__WEBPACK_IMPORTED_MODULE_3__.isIndexedDBAvailable)();
            }
            return true;
        }
    }
    catch (e) {
        // localStorage is not available from a worker. Test availability of
        // indexedDB.
        return _isWorker() && (0,_firebase_util__WEBPACK_IMPORTED_MODULE_3__.isIndexedDBAvailable)();
    }
    return false;
}
/**
 * @param {?Object=} global The optional global scope.
 * @return {boolean} Whether current environment is a worker.
 */
function _isWorker() {
    // WorkerGlobalScope only defined in worker environment.
    return (typeof global !== 'undefined' &&
        'WorkerGlobalScope' in global &&
        'importScripts' in global);
}
function _isPopupRedirectSupported() {
    return ((_isHttpOrHttps() ||
        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_3__.isBrowserExtension)() ||
        _isAndroidOrIosCordovaScheme()) &&
        // React Native with remote debugging reports its location.protocol as
        // http.
        !_isNativeEnvironment() &&
        // Local storage has to be supported for browser popup and redirect
        // operations to work.
        _isWebStorageSupported() &&
        // DOM, popups and redirects are not supported within a worker.
        !_isWorker());
}
/** Quick check that indicates the platform *may* be Cordova */
function _isLikelyCordova() {
    return _isAndroidOrIosCordovaScheme() && typeof document !== 'undefined';
}
async function _isCordova() {
    if (!_isLikelyCordova()) {
        return false;
    }
    return new Promise(resolve => {
        const timeoutId = setTimeout(() => {
            // We've waited long enough; the telltale Cordova event didn't happen
            resolve(false);
        }, CORDOVA_ONDEVICEREADY_TIMEOUT_MS);
        document.addEventListener('deviceready', () => {
            clearTimeout(timeoutId);
            resolve(true);
        });
    });
}
function _getSelfWindow() {
    return typeof window !== 'undefined' ? window : null;
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const Persistence = {
    LOCAL: 'local',
    NONE: 'none',
    SESSION: 'session'
};
const _assert$3 = _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__._assert;
const PERSISTENCE_KEY = 'persistence';
/**
 * Validates that an argument is a valid persistence value. If an invalid type
 * is specified, an error is thrown synchronously.
 */
function _validatePersistenceArgument(auth, persistence) {
    _assert$3(Object.values(Persistence).includes(persistence), auth, "invalid-persistence-type" /* INVALID_PERSISTENCE */);
    // Validate if the specified type is supported in the current environment.
    if ((0,_firebase_util__WEBPACK_IMPORTED_MODULE_3__.isReactNative)()) {
        // This is only supported in a browser.
        _assert$3(persistence !== Persistence.SESSION, auth, "unsupported-persistence-type" /* UNSUPPORTED_PERSISTENCE */);
        return;
    }
    if ((0,_firebase_util__WEBPACK_IMPORTED_MODULE_3__.isNode)()) {
        // Only none is supported in Node.js.
        _assert$3(persistence === Persistence.NONE, auth, "unsupported-persistence-type" /* UNSUPPORTED_PERSISTENCE */);
        return;
    }
    if (_isWorker()) {
        // In a worker environment, either LOCAL or NONE are supported.
        // If indexedDB not supported and LOCAL provided, throw an error
        _assert$3(persistence === Persistence.NONE ||
            (persistence === Persistence.LOCAL && (0,_firebase_util__WEBPACK_IMPORTED_MODULE_3__.isIndexedDBAvailable)()), auth, "unsupported-persistence-type" /* UNSUPPORTED_PERSISTENCE */);
        return;
    }
    // This is restricted by what the browser supports.
    _assert$3(persistence === Persistence.NONE || _isWebStorageSupported(), auth, "unsupported-persistence-type" /* UNSUPPORTED_PERSISTENCE */);
}
async function _savePersistenceForRedirect(auth) {
    await auth._initializationPromise;
    const session = getSessionStorageIfAvailable();
    const key = _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__._persistenceKeyName(PERSISTENCE_KEY, auth.config.apiKey, auth.name);
    if (session) {
        session.setItem(key, auth._getPersistence());
    }
}
function _getPersistencesFromRedirect(apiKey, appName) {
    const session = getSessionStorageIfAvailable();
    if (!session) {
        return [];
    }
    const key = _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__._persistenceKeyName(PERSISTENCE_KEY, apiKey, appName);
    const persistence = session.getItem(key);
    switch (persistence) {
        case Persistence.NONE:
            return [_firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__.inMemoryPersistence];
        case Persistence.LOCAL:
            return [_firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__.indexedDBLocalPersistence, _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__.browserSessionPersistence];
        case Persistence.SESSION:
            return [_firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__.browserSessionPersistence];
        default:
            return [];
    }
}
/** Returns session storage, or null if the property access errors */
function getSessionStorageIfAvailable() {
    var _a;
    try {
        return ((_a = _getSelfWindow()) === null || _a === void 0 ? void 0 : _a.sessionStorage) || null;
    }
    catch (e) {
        return null;
    }
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const _assert$2 = _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__._assert;
/** Platform-agnostic popup-redirect resolver */
class CompatPopupRedirectResolver {
    constructor() {
        // Create both resolvers for dynamic resolution later
        this.browserResolver = _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__._getInstance(_firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__.browserPopupRedirectResolver);
        this.cordovaResolver = _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__._getInstance(_firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__.cordovaPopupRedirectResolver);
        // The actual resolver in use: either browserResolver or cordovaResolver.
        this.underlyingResolver = null;
        this._redirectPersistence = _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__.browserSessionPersistence;
        this._completeRedirectFn = _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__._getRedirectResult;
    }
    async _initialize(auth) {
        await this.selectUnderlyingResolver();
        return this.assertedUnderlyingResolver._initialize(auth);
    }
    async _openPopup(auth, provider, authType, eventId) {
        await this.selectUnderlyingResolver();
        return this.assertedUnderlyingResolver._openPopup(auth, provider, authType, eventId);
    }
    async _openRedirect(auth, provider, authType, eventId) {
        await this.selectUnderlyingResolver();
        return this.assertedUnderlyingResolver._openRedirect(auth, provider, authType, eventId);
    }
    _isIframeWebStorageSupported(auth, cb) {
        this.assertedUnderlyingResolver._isIframeWebStorageSupported(auth, cb);
    }
    _originValidation(auth) {
        return this.assertedUnderlyingResolver._originValidation(auth);
    }
    get _shouldInitProactively() {
        return _isLikelyCordova() || this.browserResolver._shouldInitProactively;
    }
    get assertedUnderlyingResolver() {
        _assert$2(this.underlyingResolver, "internal-error" /* INTERNAL_ERROR */);
        return this.underlyingResolver;
    }
    async selectUnderlyingResolver() {
        if (this.underlyingResolver) {
            return;
        }
        // We haven't yet determined whether or not we're in Cordova; go ahead
        // and determine that state now.
        const isCordova = await _isCordova();
        this.underlyingResolver = isCordova
            ? this.cordovaResolver
            : this.browserResolver;
    }
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function unwrap(object) {
    return object.unwrap();
}
function wrapped(object) {
    return object.wrapped();
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function credentialFromResponse(userCredential) {
    return credentialFromObject(userCredential);
}
function attachExtraErrorFields(auth, e) {
    var _a;
    // The response contains all fields from the server which may or may not
    // actually match the underlying type
    const response = (_a = e.customData) === null || _a === void 0 ? void 0 : _a._tokenResponse;
    if (e.code === 'auth/multi-factor-auth-required') {
        const mfaErr = e;
        mfaErr.resolver = new MultiFactorResolver(auth, _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__.getMultiFactorResolver(auth, e));
    }
    else if (response) {
        const credential = credentialFromObject(e);
        const credErr = e;
        if (credential) {
            credErr.credential = credential;
            credErr.tenantId = response.tenantId || undefined;
            credErr.email = response.email || undefined;
            credErr.phoneNumber = response.phoneNumber || undefined;
        }
    }
}
function credentialFromObject(object) {
    const { _tokenResponse } = (object instanceof _firebase_util__WEBPACK_IMPORTED_MODULE_3__.FirebaseError ? object.customData : object);
    if (!_tokenResponse) {
        return null;
    }
    // Handle phone Auth credential responses, as they have a different format
    // from other backend responses (i.e. no providerId). This is also only the
    // case for user credentials (does not work for errors).
    if (!(object instanceof _firebase_util__WEBPACK_IMPORTED_MODULE_3__.FirebaseError)) {
        if ('temporaryProof' in _tokenResponse && 'phoneNumber' in _tokenResponse) {
            return _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__.PhoneAuthProvider.credentialFromResult(object);
        }
    }
    const providerId = _tokenResponse.providerId;
    // Email and password is not supported as there is no situation where the
    // server would return the password to the client.
    if (!providerId || providerId === _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__.ProviderId.PASSWORD) {
        return null;
    }
    let provider;
    switch (providerId) {
        case _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__.ProviderId.GOOGLE:
            provider = _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__.GoogleAuthProvider;
            break;
        case _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__.ProviderId.FACEBOOK:
            provider = _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__.FacebookAuthProvider;
            break;
        case _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__.ProviderId.GITHUB:
            provider = _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__.GithubAuthProvider;
            break;
        case _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__.ProviderId.TWITTER:
            provider = _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__.TwitterAuthProvider;
            break;
        default:
            const { oauthIdToken, oauthAccessToken, oauthTokenSecret, pendingToken, nonce } = _tokenResponse;
            if (!oauthAccessToken &&
                !oauthTokenSecret &&
                !oauthIdToken &&
                !pendingToken) {
                return null;
            }
            // TODO(avolkovi): uncomment this and get it working with SAML & OIDC
            if (pendingToken) {
                if (providerId.startsWith('saml.')) {
                    return _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__.SAMLAuthCredential._create(providerId, pendingToken);
                }
                else {
                    // OIDC and non-default providers excluding Twitter.
                    return _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__.OAuthCredential._fromParams({
                        providerId,
                        signInMethod: providerId,
                        pendingToken,
                        idToken: oauthIdToken,
                        accessToken: oauthAccessToken
                    });
                }
            }
            return new _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__.OAuthProvider(providerId).credential({
                idToken: oauthIdToken,
                accessToken: oauthAccessToken,
                rawNonce: nonce
            });
    }
    return object instanceof _firebase_util__WEBPACK_IMPORTED_MODULE_3__.FirebaseError
        ? provider.credentialFromError(object)
        : provider.credentialFromResult(object);
}
function convertCredential(auth, credentialPromise) {
    return credentialPromise
        .catch(e => {
        if (e instanceof _firebase_util__WEBPACK_IMPORTED_MODULE_3__.FirebaseError) {
            attachExtraErrorFields(auth, e);
        }
        throw e;
    })
        .then(credential => {
        const operationType = credential.operationType;
        const user = credential.user;
        return {
            operationType,
            credential: credentialFromResponse(credential),
            additionalUserInfo: _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__.getAdditionalUserInfo(credential),
            user: User.getOrCreate(user)
        };
    });
}
async function convertConfirmationResult(auth, confirmationResultPromise) {
    const confirmationResultExp = await confirmationResultPromise;
    return {
        verificationId: confirmationResultExp.verificationId,
        confirm: (verificationCode) => convertCredential(auth, confirmationResultExp.confirm(verificationCode))
    };
}
class MultiFactorResolver {
    constructor(auth, resolver) {
        this.resolver = resolver;
        this.auth = wrapped(auth);
    }
    get session() {
        return this.resolver.session;
    }
    get hints() {
        return this.resolver.hints;
    }
    resolveSignIn(assertion) {
        return convertCredential(unwrap(this.auth), this.resolver.resolveSignIn(assertion));
    }
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class User {
    constructor(_delegate) {
        this._delegate = _delegate;
        this.multiFactor = _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__.multiFactor(_delegate);
    }
    static getOrCreate(user) {
        if (!User.USER_MAP.has(user)) {
            User.USER_MAP.set(user, new User(user));
        }
        return User.USER_MAP.get(user);
    }
    delete() {
        return this._delegate.delete();
    }
    reload() {
        return this._delegate.reload();
    }
    toJSON() {
        return this._delegate.toJSON();
    }
    getIdTokenResult(forceRefresh) {
        return this._delegate.getIdTokenResult(forceRefresh);
    }
    getIdToken(forceRefresh) {
        return this._delegate.getIdToken(forceRefresh);
    }
    linkAndRetrieveDataWithCredential(credential) {
        return this.linkWithCredential(credential);
    }
    async linkWithCredential(credential) {
        return convertCredential(this.auth, _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__.linkWithCredential(this._delegate, credential));
    }
    async linkWithPhoneNumber(phoneNumber, applicationVerifier) {
        return convertConfirmationResult(this.auth, _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__.linkWithPhoneNumber(this._delegate, phoneNumber, applicationVerifier));
    }
    async linkWithPopup(provider) {
        return convertCredential(this.auth, _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__.linkWithPopup(this._delegate, provider, CompatPopupRedirectResolver));
    }
    async linkWithRedirect(provider) {
        await _savePersistenceForRedirect(_firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__._castAuth(this.auth));
        return _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__.linkWithRedirect(this._delegate, provider, CompatPopupRedirectResolver);
    }
    reauthenticateAndRetrieveDataWithCredential(credential) {
        return this.reauthenticateWithCredential(credential);
    }
    async reauthenticateWithCredential(credential) {
        return convertCredential(this.auth, _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__.reauthenticateWithCredential(this._delegate, credential));
    }
    reauthenticateWithPhoneNumber(phoneNumber, applicationVerifier) {
        return convertConfirmationResult(this.auth, _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__.reauthenticateWithPhoneNumber(this._delegate, phoneNumber, applicationVerifier));
    }
    reauthenticateWithPopup(provider) {
        return convertCredential(this.auth, _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__.reauthenticateWithPopup(this._delegate, provider, CompatPopupRedirectResolver));
    }
    async reauthenticateWithRedirect(provider) {
        await _savePersistenceForRedirect(_firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__._castAuth(this.auth));
        return _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__.reauthenticateWithRedirect(this._delegate, provider, CompatPopupRedirectResolver);
    }
    sendEmailVerification(actionCodeSettings) {
        return _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__.sendEmailVerification(this._delegate, actionCodeSettings);
    }
    async unlink(providerId) {
        await _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__.unlink(this._delegate, providerId);
        return this;
    }
    updateEmail(newEmail) {
        return _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__.updateEmail(this._delegate, newEmail);
    }
    updatePassword(newPassword) {
        return _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__.updatePassword(this._delegate, newPassword);
    }
    updatePhoneNumber(phoneCredential) {
        return _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__.updatePhoneNumber(this._delegate, phoneCredential);
    }
    updateProfile(profile) {
        return _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__.updateProfile(this._delegate, profile);
    }
    verifyBeforeUpdateEmail(newEmail, actionCodeSettings) {
        return _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__.verifyBeforeUpdateEmail(this._delegate, newEmail, actionCodeSettings);
    }
    get emailVerified() {
        return this._delegate.emailVerified;
    }
    get isAnonymous() {
        return this._delegate.isAnonymous;
    }
    get metadata() {
        return this._delegate.metadata;
    }
    get phoneNumber() {
        return this._delegate.phoneNumber;
    }
    get providerData() {
        return this._delegate.providerData;
    }
    get refreshToken() {
        return this._delegate.refreshToken;
    }
    get tenantId() {
        return this._delegate.tenantId;
    }
    get displayName() {
        return this._delegate.displayName;
    }
    get email() {
        return this._delegate.email;
    }
    get photoURL() {
        return this._delegate.photoURL;
    }
    get providerId() {
        return this._delegate.providerId;
    }
    get uid() {
        return this._delegate.uid;
    }
    get auth() {
        return this._delegate.auth;
    }
}
// Maintain a map so that there's always a 1:1 mapping between new User and
// legacy compat users
User.USER_MAP = new WeakMap();

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const _assert$1 = _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__._assert;
class Auth {
    constructor(app, provider) {
        this.app = app;
        if (provider.isInitialized()) {
            this._delegate = provider.getImmediate();
            this.linkUnderlyingAuth();
            return;
        }
        const { apiKey } = app.options;
        // TODO: platform needs to be determined using heuristics
        _assert$1(apiKey, "invalid-api-key" /* INVALID_API_KEY */, {
            appName: app.name
        });
        // TODO: platform needs to be determined using heuristics
        _assert$1(apiKey, "invalid-api-key" /* INVALID_API_KEY */, {
            appName: app.name
        });
        // Only use a popup/redirect resolver in browser environments
        const resolver = typeof window !== 'undefined' ? CompatPopupRedirectResolver : undefined;
        this._delegate = provider.initialize({
            options: {
                persistence: buildPersistenceHierarchy(apiKey, app.name),
                popupRedirectResolver: resolver
            }
        });
        this._delegate._updateErrorMap(_firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__.debugErrorMap);
        this.linkUnderlyingAuth();
    }
    get emulatorConfig() {
        return this._delegate.emulatorConfig;
    }
    get currentUser() {
        if (!this._delegate.currentUser) {
            return null;
        }
        return User.getOrCreate(this._delegate.currentUser);
    }
    get languageCode() {
        return this._delegate.languageCode;
    }
    set languageCode(languageCode) {
        this._delegate.languageCode = languageCode;
    }
    get settings() {
        return this._delegate.settings;
    }
    get tenantId() {
        return this._delegate.tenantId;
    }
    set tenantId(tid) {
        this._delegate.tenantId = tid;
    }
    useDeviceLanguage() {
        this._delegate.useDeviceLanguage();
    }
    signOut() {
        return this._delegate.signOut();
    }
    useEmulator(url, options) {
        _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__.connectAuthEmulator(this._delegate, url, options);
    }
    applyActionCode(code) {
        return _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__.applyActionCode(this._delegate, code);
    }
    checkActionCode(code) {
        return _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__.checkActionCode(this._delegate, code);
    }
    confirmPasswordReset(code, newPassword) {
        return _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__.confirmPasswordReset(this._delegate, code, newPassword);
    }
    async createUserWithEmailAndPassword(email, password) {
        return convertCredential(this._delegate, _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__.createUserWithEmailAndPassword(this._delegate, email, password));
    }
    fetchProvidersForEmail(email) {
        return this.fetchSignInMethodsForEmail(email);
    }
    fetchSignInMethodsForEmail(email) {
        return _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__.fetchSignInMethodsForEmail(this._delegate, email);
    }
    isSignInWithEmailLink(emailLink) {
        return _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__.isSignInWithEmailLink(this._delegate, emailLink);
    }
    async getRedirectResult() {
        _assert$1(_isPopupRedirectSupported(), this._delegate, "operation-not-supported-in-this-environment" /* OPERATION_NOT_SUPPORTED */);
        const credential = await _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__.getRedirectResult(this._delegate, CompatPopupRedirectResolver);
        if (!credential) {
            return {
                credential: null,
                user: null
            };
        }
        return convertCredential(this._delegate, Promise.resolve(credential));
    }
    // This function should only be called by frameworks (e.g. FirebaseUI-web) to log their usage.
    // It is not intended for direct use by developer apps. NO jsdoc here to intentionally leave it
    // out of autogenerated documentation pages to reduce accidental misuse.
    addFrameworkForLogging(framework) {
        _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__.addFrameworkForLogging(this._delegate, framework);
    }
    onAuthStateChanged(nextOrObserver, errorFn, completed) {
        const { next, error, complete } = wrapObservers(nextOrObserver, errorFn, completed);
        return this._delegate.onAuthStateChanged(next, error, complete);
    }
    onIdTokenChanged(nextOrObserver, errorFn, completed) {
        const { next, error, complete } = wrapObservers(nextOrObserver, errorFn, completed);
        return this._delegate.onIdTokenChanged(next, error, complete);
    }
    sendSignInLinkToEmail(email, actionCodeSettings) {
        return _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__.sendSignInLinkToEmail(this._delegate, email, actionCodeSettings);
    }
    sendPasswordResetEmail(email, actionCodeSettings) {
        return _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__.sendPasswordResetEmail(this._delegate, email, actionCodeSettings || undefined);
    }
    async setPersistence(persistence) {
        _validatePersistenceArgument(this._delegate, persistence);
        let converted;
        switch (persistence) {
            case Persistence.SESSION:
                converted = _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__.browserSessionPersistence;
                break;
            case Persistence.LOCAL:
                // Not using isIndexedDBAvailable() since it only checks if indexedDB is defined.
                const isIndexedDBFullySupported = await _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__._getInstance(_firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__.indexedDBLocalPersistence)
                    ._isAvailable();
                converted = isIndexedDBFullySupported
                    ? _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__.indexedDBLocalPersistence
                    : _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__.browserLocalPersistence;
                break;
            case Persistence.NONE:
                converted = _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__.inMemoryPersistence;
                break;
            default:
                return _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__._fail("argument-error" /* ARGUMENT_ERROR */, {
                    appName: this._delegate.name
                });
        }
        return this._delegate.setPersistence(converted);
    }
    signInAndRetrieveDataWithCredential(credential) {
        return this.signInWithCredential(credential);
    }
    signInAnonymously() {
        return convertCredential(this._delegate, _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__.signInAnonymously(this._delegate));
    }
    signInWithCredential(credential) {
        return convertCredential(this._delegate, _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__.signInWithCredential(this._delegate, credential));
    }
    signInWithCustomToken(token) {
        return convertCredential(this._delegate, _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__.signInWithCustomToken(this._delegate, token));
    }
    signInWithEmailAndPassword(email, password) {
        return convertCredential(this._delegate, _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__.signInWithEmailAndPassword(this._delegate, email, password));
    }
    signInWithEmailLink(email, emailLink) {
        return convertCredential(this._delegate, _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__.signInWithEmailLink(this._delegate, email, emailLink));
    }
    signInWithPhoneNumber(phoneNumber, applicationVerifier) {
        return convertConfirmationResult(this._delegate, _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__.signInWithPhoneNumber(this._delegate, phoneNumber, applicationVerifier));
    }
    async signInWithPopup(provider) {
        _assert$1(_isPopupRedirectSupported(), this._delegate, "operation-not-supported-in-this-environment" /* OPERATION_NOT_SUPPORTED */);
        return convertCredential(this._delegate, _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__.signInWithPopup(this._delegate, provider, CompatPopupRedirectResolver));
    }
    async signInWithRedirect(provider) {
        _assert$1(_isPopupRedirectSupported(), this._delegate, "operation-not-supported-in-this-environment" /* OPERATION_NOT_SUPPORTED */);
        await _savePersistenceForRedirect(this._delegate);
        return _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__.signInWithRedirect(this._delegate, provider, CompatPopupRedirectResolver);
    }
    updateCurrentUser(user) {
        // remove ts-ignore once overloads are defined for exp functions to accept compat objects
        // @ts-ignore
        return this._delegate.updateCurrentUser(user);
    }
    verifyPasswordResetCode(code) {
        return _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__.verifyPasswordResetCode(this._delegate, code);
    }
    unwrap() {
        return this._delegate;
    }
    _delete() {
        return this._delegate._delete();
    }
    linkUnderlyingAuth() {
        this._delegate.wrapped = () => this;
    }
}
Auth.Persistence = Persistence;
function wrapObservers(nextOrObserver, error, complete) {
    let next = nextOrObserver;
    if (typeof nextOrObserver !== 'function') {
        ({ next, error, complete } = nextOrObserver);
    }
    // We know 'next' is now a function
    const oldNext = next;
    const newNext = (user) => oldNext(user && User.getOrCreate(user));
    return {
        next: newNext,
        error: error,
        complete
    };
}
function buildPersistenceHierarchy(apiKey, appName) {
    // Note this is slightly different behavior: in this case, the stored
    // persistence is checked *first* rather than last. This is because we want
    // to prefer stored persistence type in the hierarchy. This is an empty
    // array if window is not available or there is no pending redirect
    const persistences = _getPersistencesFromRedirect(apiKey, appName);
    // If "self" is available, add indexedDB
    if (typeof self !== 'undefined' &&
        !persistences.includes(_firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__.indexedDBLocalPersistence)) {
        persistences.push(_firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__.indexedDBLocalPersistence);
    }
    // If "window" is available, add HTML Storage persistences
    if (typeof window !== 'undefined') {
        for (const persistence of [
            _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__.browserLocalPersistence,
            _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__.browserSessionPersistence
        ]) {
            if (!persistences.includes(persistence)) {
                persistences.push(persistence);
            }
        }
    }
    // Add in-memory as a final fallback
    if (!persistences.includes(_firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__.inMemoryPersistence)) {
        persistences.push(_firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__.inMemoryPersistence);
    }
    return persistences;
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class PhoneAuthProvider {
    constructor() {
        this.providerId = 'phone';
        // TODO: remove ts-ignore when moving types from auth-types to auth-compat
        // @ts-ignore
        this._delegate = new _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__.PhoneAuthProvider(unwrap(_firebase_app_compat__WEBPACK_IMPORTED_MODULE_0__.default.auth()));
    }
    static credential(verificationId, verificationCode) {
        return _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__.PhoneAuthProvider.credential(verificationId, verificationCode);
    }
    verifyPhoneNumber(phoneInfoOptions, applicationVerifier) {
        return this._delegate.verifyPhoneNumber(
        // The implementation matches but the types are subtly incompatible
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        phoneInfoOptions, applicationVerifier);
    }
    unwrap() {
        return this._delegate;
    }
}
PhoneAuthProvider.PHONE_SIGN_IN_METHOD = _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__.PhoneAuthProvider.PHONE_SIGN_IN_METHOD;
PhoneAuthProvider.PROVIDER_ID = _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__.PhoneAuthProvider.PROVIDER_ID;

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const _assert = _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__._assert;
class RecaptchaVerifier {
    constructor(container, parameters, app = _firebase_app_compat__WEBPACK_IMPORTED_MODULE_0__.default.app()) {
        var _a;
        // API key is required for web client RPC calls.
        _assert((_a = app.options) === null || _a === void 0 ? void 0 : _a.apiKey, "invalid-api-key" /* INVALID_API_KEY */, {
            appName: app.name
        });
        this._delegate = new _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__.RecaptchaVerifier(container, 
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        parameters, 
        // TODO: remove ts-ignore when moving types from auth-types to auth-compat
        // @ts-ignore
        app.auth());
        this.type = this._delegate.type;
    }
    clear() {
        this._delegate.clear();
    }
    render() {
        return this._delegate.render();
    }
    verify() {
        return this._delegate.verify();
    }
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const AUTH_TYPE = 'auth-compat';
// Create auth components to register with firebase.
// Provides Auth public APIs.
function registerAuthCompat(instance) {
    instance.INTERNAL.registerComponent(new _firebase_component__WEBPACK_IMPORTED_MODULE_2__.Component(AUTH_TYPE, container => {
        // getImmediate for FirebaseApp will always succeed
        const app = container.getProvider('app-compat').getImmediate();
        const authProvider = container.getProvider('auth');
        return new Auth(app, authProvider);
    }, "PUBLIC" /* PUBLIC */)
        .setServiceProps({
        ActionCodeInfo: {
            Operation: {
                EMAIL_SIGNIN: _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__.ActionCodeOperation.EMAIL_SIGNIN,
                PASSWORD_RESET: _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__.ActionCodeOperation.PASSWORD_RESET,
                RECOVER_EMAIL: _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__.ActionCodeOperation.RECOVER_EMAIL,
                REVERT_SECOND_FACTOR_ADDITION: _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__.ActionCodeOperation.REVERT_SECOND_FACTOR_ADDITION,
                VERIFY_AND_CHANGE_EMAIL: _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__.ActionCodeOperation.VERIFY_AND_CHANGE_EMAIL,
                VERIFY_EMAIL: _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__.ActionCodeOperation.VERIFY_EMAIL
            }
        },
        EmailAuthProvider: _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__.EmailAuthProvider,
        FacebookAuthProvider: _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__.FacebookAuthProvider,
        GithubAuthProvider: _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__.GithubAuthProvider,
        GoogleAuthProvider: _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__.GoogleAuthProvider,
        OAuthProvider: _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__.OAuthProvider,
        SAMLAuthProvider: _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__.SAMLAuthProvider,
        PhoneAuthProvider: PhoneAuthProvider,
        PhoneMultiFactorGenerator: _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__.PhoneMultiFactorGenerator,
        RecaptchaVerifier: RecaptchaVerifier,
        TwitterAuthProvider: _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__.TwitterAuthProvider,
        Auth,
        AuthCredential: _firebase_auth_internal__WEBPACK_IMPORTED_MODULE_1__.AuthCredential,
        Error: _firebase_util__WEBPACK_IMPORTED_MODULE_3__.FirebaseError
    })
        .setInstantiationMode("LAZY" /* LAZY */)
        .setMultipleInstances(false));
    instance.registerVersion(name, version);
}
registerAuthCompat(_firebase_app_compat__WEBPACK_IMPORTED_MODULE_0__.default);
//# sourceMappingURL=index.esm2017.js.map


/***/ }),

/***/ 58098:
/*!**************************************************************!*\
  !*** ./node_modules/@firebase/auth/dist/esm2017/internal.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ActionCodeOperation": () => (/* reexport safe */ _index_585b6059_js__WEBPACK_IMPORTED_MODULE_0__.A),
/* harmony export */   "ActionCodeURL": () => (/* reexport safe */ _index_585b6059_js__WEBPACK_IMPORTED_MODULE_0__.ac),
/* harmony export */   "AuthCredential": () => (/* reexport safe */ _index_585b6059_js__WEBPACK_IMPORTED_MODULE_0__.G),
/* harmony export */   "AuthErrorCodes": () => (/* reexport safe */ _index_585b6059_js__WEBPACK_IMPORTED_MODULE_0__.C),
/* harmony export */   "AuthImpl": () => (/* reexport safe */ _index_585b6059_js__WEBPACK_IMPORTED_MODULE_0__.aE),
/* harmony export */   "AuthPopup": () => (/* reexport safe */ _index_585b6059_js__WEBPACK_IMPORTED_MODULE_0__.aH),
/* harmony export */   "EmailAuthCredential": () => (/* reexport safe */ _index_585b6059_js__WEBPACK_IMPORTED_MODULE_0__.H),
/* harmony export */   "EmailAuthProvider": () => (/* reexport safe */ _index_585b6059_js__WEBPACK_IMPORTED_MODULE_0__.L),
/* harmony export */   "FacebookAuthProvider": () => (/* reexport safe */ _index_585b6059_js__WEBPACK_IMPORTED_MODULE_0__.M),
/* harmony export */   "FactorId": () => (/* reexport safe */ _index_585b6059_js__WEBPACK_IMPORTED_MODULE_0__.F),
/* harmony export */   "FetchProvider": () => (/* reexport safe */ _index_585b6059_js__WEBPACK_IMPORTED_MODULE_0__.aI),
/* harmony export */   "GithubAuthProvider": () => (/* reexport safe */ _index_585b6059_js__WEBPACK_IMPORTED_MODULE_0__.Q),
/* harmony export */   "GoogleAuthProvider": () => (/* reexport safe */ _index_585b6059_js__WEBPACK_IMPORTED_MODULE_0__.N),
/* harmony export */   "OAuthCredential": () => (/* reexport safe */ _index_585b6059_js__WEBPACK_IMPORTED_MODULE_0__.I),
/* harmony export */   "OAuthProvider": () => (/* reexport safe */ _index_585b6059_js__WEBPACK_IMPORTED_MODULE_0__.T),
/* harmony export */   "OperationType": () => (/* reexport safe */ _index_585b6059_js__WEBPACK_IMPORTED_MODULE_0__.O),
/* harmony export */   "PhoneAuthCredential": () => (/* reexport safe */ _index_585b6059_js__WEBPACK_IMPORTED_MODULE_0__.J),
/* harmony export */   "PhoneAuthProvider": () => (/* reexport safe */ _index_585b6059_js__WEBPACK_IMPORTED_MODULE_0__.P),
/* harmony export */   "PhoneMultiFactorGenerator": () => (/* reexport safe */ _index_585b6059_js__WEBPACK_IMPORTED_MODULE_0__.m),
/* harmony export */   "ProviderId": () => (/* reexport safe */ _index_585b6059_js__WEBPACK_IMPORTED_MODULE_0__.o),
/* harmony export */   "RecaptchaVerifier": () => (/* reexport safe */ _index_585b6059_js__WEBPACK_IMPORTED_MODULE_0__.R),
/* harmony export */   "SAMLAuthCredential": () => (/* reexport safe */ _index_585b6059_js__WEBPACK_IMPORTED_MODULE_0__.aJ),
/* harmony export */   "SAMLAuthProvider": () => (/* reexport safe */ _index_585b6059_js__WEBPACK_IMPORTED_MODULE_0__.U),
/* harmony export */   "SignInMethod": () => (/* reexport safe */ _index_585b6059_js__WEBPACK_IMPORTED_MODULE_0__.S),
/* harmony export */   "TwitterAuthProvider": () => (/* reexport safe */ _index_585b6059_js__WEBPACK_IMPORTED_MODULE_0__.V),
/* harmony export */   "UserImpl": () => (/* reexport safe */ _index_585b6059_js__WEBPACK_IMPORTED_MODULE_0__.aD),
/* harmony export */   "_assert": () => (/* reexport safe */ _index_585b6059_js__WEBPACK_IMPORTED_MODULE_0__.aw),
/* harmony export */   "_castAuth": () => (/* reexport safe */ _index_585b6059_js__WEBPACK_IMPORTED_MODULE_0__.aC),
/* harmony export */   "_fail": () => (/* reexport safe */ _index_585b6059_js__WEBPACK_IMPORTED_MODULE_0__.as),
/* harmony export */   "_generateEventId": () => (/* reexport safe */ _index_585b6059_js__WEBPACK_IMPORTED_MODULE_0__.aG),
/* harmony export */   "_getClientVersion": () => (/* reexport safe */ _index_585b6059_js__WEBPACK_IMPORTED_MODULE_0__.aF),
/* harmony export */   "_getInstance": () => (/* reexport safe */ _index_585b6059_js__WEBPACK_IMPORTED_MODULE_0__.ax),
/* harmony export */   "_getRedirectResult": () => (/* reexport safe */ _index_585b6059_js__WEBPACK_IMPORTED_MODULE_0__.aA),
/* harmony export */   "_persistenceKeyName": () => (/* reexport safe */ _index_585b6059_js__WEBPACK_IMPORTED_MODULE_0__.ay),
/* harmony export */   "applyActionCode": () => (/* reexport safe */ _index_585b6059_js__WEBPACK_IMPORTED_MODULE_0__.a1),
/* harmony export */   "browserLocalPersistence": () => (/* reexport safe */ _index_585b6059_js__WEBPACK_IMPORTED_MODULE_0__.b),
/* harmony export */   "browserPopupRedirectResolver": () => (/* reexport safe */ _index_585b6059_js__WEBPACK_IMPORTED_MODULE_0__.k),
/* harmony export */   "browserSessionPersistence": () => (/* reexport safe */ _index_585b6059_js__WEBPACK_IMPORTED_MODULE_0__.a),
/* harmony export */   "checkActionCode": () => (/* reexport safe */ _index_585b6059_js__WEBPACK_IMPORTED_MODULE_0__.a2),
/* harmony export */   "confirmPasswordReset": () => (/* reexport safe */ _index_585b6059_js__WEBPACK_IMPORTED_MODULE_0__.a0),
/* harmony export */   "connectAuthEmulator": () => (/* reexport safe */ _index_585b6059_js__WEBPACK_IMPORTED_MODULE_0__.E),
/* harmony export */   "createUserWithEmailAndPassword": () => (/* reexport safe */ _index_585b6059_js__WEBPACK_IMPORTED_MODULE_0__.a4),
/* harmony export */   "debugErrorMap": () => (/* reexport safe */ _index_585b6059_js__WEBPACK_IMPORTED_MODULE_0__.z),
/* harmony export */   "deleteUser": () => (/* reexport safe */ _index_585b6059_js__WEBPACK_IMPORTED_MODULE_0__.y),
/* harmony export */   "fetchSignInMethodsForEmail": () => (/* reexport safe */ _index_585b6059_js__WEBPACK_IMPORTED_MODULE_0__.a9),
/* harmony export */   "getAdditionalUserInfo": () => (/* reexport safe */ _index_585b6059_js__WEBPACK_IMPORTED_MODULE_0__.ak),
/* harmony export */   "getAuth": () => (/* reexport safe */ _index_585b6059_js__WEBPACK_IMPORTED_MODULE_0__.n),
/* harmony export */   "getIdToken": () => (/* reexport safe */ _index_585b6059_js__WEBPACK_IMPORTED_MODULE_0__.ah),
/* harmony export */   "getIdTokenResult": () => (/* reexport safe */ _index_585b6059_js__WEBPACK_IMPORTED_MODULE_0__.ai),
/* harmony export */   "getMultiFactorResolver": () => (/* reexport safe */ _index_585b6059_js__WEBPACK_IMPORTED_MODULE_0__.am),
/* harmony export */   "getRedirectResult": () => (/* reexport safe */ _index_585b6059_js__WEBPACK_IMPORTED_MODULE_0__.j),
/* harmony export */   "inMemoryPersistence": () => (/* reexport safe */ _index_585b6059_js__WEBPACK_IMPORTED_MODULE_0__.K),
/* harmony export */   "indexedDBLocalPersistence": () => (/* reexport safe */ _index_585b6059_js__WEBPACK_IMPORTED_MODULE_0__.i),
/* harmony export */   "initializeAuth": () => (/* reexport safe */ _index_585b6059_js__WEBPACK_IMPORTED_MODULE_0__.D),
/* harmony export */   "isSignInWithEmailLink": () => (/* reexport safe */ _index_585b6059_js__WEBPACK_IMPORTED_MODULE_0__.a7),
/* harmony export */   "linkWithCredential": () => (/* reexport safe */ _index_585b6059_js__WEBPACK_IMPORTED_MODULE_0__.Y),
/* harmony export */   "linkWithPhoneNumber": () => (/* reexport safe */ _index_585b6059_js__WEBPACK_IMPORTED_MODULE_0__.l),
/* harmony export */   "linkWithPopup": () => (/* reexport safe */ _index_585b6059_js__WEBPACK_IMPORTED_MODULE_0__.d),
/* harmony export */   "linkWithRedirect": () => (/* reexport safe */ _index_585b6059_js__WEBPACK_IMPORTED_MODULE_0__.g),
/* harmony export */   "multiFactor": () => (/* reexport safe */ _index_585b6059_js__WEBPACK_IMPORTED_MODULE_0__.an),
/* harmony export */   "onAuthStateChanged": () => (/* reexport safe */ _index_585b6059_js__WEBPACK_IMPORTED_MODULE_0__.t),
/* harmony export */   "onIdTokenChanged": () => (/* reexport safe */ _index_585b6059_js__WEBPACK_IMPORTED_MODULE_0__.q),
/* harmony export */   "parseActionCodeURL": () => (/* reexport safe */ _index_585b6059_js__WEBPACK_IMPORTED_MODULE_0__.ad),
/* harmony export */   "prodErrorMap": () => (/* reexport safe */ _index_585b6059_js__WEBPACK_IMPORTED_MODULE_0__.B),
/* harmony export */   "reauthenticateWithCredential": () => (/* reexport safe */ _index_585b6059_js__WEBPACK_IMPORTED_MODULE_0__.Z),
/* harmony export */   "reauthenticateWithPhoneNumber": () => (/* reexport safe */ _index_585b6059_js__WEBPACK_IMPORTED_MODULE_0__.r),
/* harmony export */   "reauthenticateWithPopup": () => (/* reexport safe */ _index_585b6059_js__WEBPACK_IMPORTED_MODULE_0__.e),
/* harmony export */   "reauthenticateWithRedirect": () => (/* reexport safe */ _index_585b6059_js__WEBPACK_IMPORTED_MODULE_0__.h),
/* harmony export */   "reload": () => (/* reexport safe */ _index_585b6059_js__WEBPACK_IMPORTED_MODULE_0__.al),
/* harmony export */   "sendEmailVerification": () => (/* reexport safe */ _index_585b6059_js__WEBPACK_IMPORTED_MODULE_0__.aa),
/* harmony export */   "sendPasswordResetEmail": () => (/* reexport safe */ _index_585b6059_js__WEBPACK_IMPORTED_MODULE_0__.$),
/* harmony export */   "sendSignInLinkToEmail": () => (/* reexport safe */ _index_585b6059_js__WEBPACK_IMPORTED_MODULE_0__.a6),
/* harmony export */   "setPersistence": () => (/* reexport safe */ _index_585b6059_js__WEBPACK_IMPORTED_MODULE_0__.p),
/* harmony export */   "signInAnonymously": () => (/* reexport safe */ _index_585b6059_js__WEBPACK_IMPORTED_MODULE_0__.W),
/* harmony export */   "signInWithCredential": () => (/* reexport safe */ _index_585b6059_js__WEBPACK_IMPORTED_MODULE_0__.X),
/* harmony export */   "signInWithCustomToken": () => (/* reexport safe */ _index_585b6059_js__WEBPACK_IMPORTED_MODULE_0__._),
/* harmony export */   "signInWithEmailAndPassword": () => (/* reexport safe */ _index_585b6059_js__WEBPACK_IMPORTED_MODULE_0__.a5),
/* harmony export */   "signInWithEmailLink": () => (/* reexport safe */ _index_585b6059_js__WEBPACK_IMPORTED_MODULE_0__.a8),
/* harmony export */   "signInWithPhoneNumber": () => (/* reexport safe */ _index_585b6059_js__WEBPACK_IMPORTED_MODULE_0__.s),
/* harmony export */   "signInWithPopup": () => (/* reexport safe */ _index_585b6059_js__WEBPACK_IMPORTED_MODULE_0__.c),
/* harmony export */   "signInWithRedirect": () => (/* reexport safe */ _index_585b6059_js__WEBPACK_IMPORTED_MODULE_0__.f),
/* harmony export */   "signOut": () => (/* reexport safe */ _index_585b6059_js__WEBPACK_IMPORTED_MODULE_0__.x),
/* harmony export */   "unlink": () => (/* reexport safe */ _index_585b6059_js__WEBPACK_IMPORTED_MODULE_0__.aj),
/* harmony export */   "updateCurrentUser": () => (/* reexport safe */ _index_585b6059_js__WEBPACK_IMPORTED_MODULE_0__.w),
/* harmony export */   "updateEmail": () => (/* reexport safe */ _index_585b6059_js__WEBPACK_IMPORTED_MODULE_0__.af),
/* harmony export */   "updatePassword": () => (/* reexport safe */ _index_585b6059_js__WEBPACK_IMPORTED_MODULE_0__.ag),
/* harmony export */   "updatePhoneNumber": () => (/* reexport safe */ _index_585b6059_js__WEBPACK_IMPORTED_MODULE_0__.u),
/* harmony export */   "updateProfile": () => (/* reexport safe */ _index_585b6059_js__WEBPACK_IMPORTED_MODULE_0__.ae),
/* harmony export */   "useDeviceLanguage": () => (/* reexport safe */ _index_585b6059_js__WEBPACK_IMPORTED_MODULE_0__.v),
/* harmony export */   "verifyBeforeUpdateEmail": () => (/* reexport safe */ _index_585b6059_js__WEBPACK_IMPORTED_MODULE_0__.ab),
/* harmony export */   "verifyPasswordResetCode": () => (/* reexport safe */ _index_585b6059_js__WEBPACK_IMPORTED_MODULE_0__.a3),
/* harmony export */   "addFrameworkForLogging": () => (/* binding */ addFrameworkForLogging),
/* harmony export */   "cordovaPopupRedirectResolver": () => (/* binding */ cordovaPopupRedirectResolver)
/* harmony export */ });
/* harmony import */ var _index_585b6059_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index-585b6059.js */ 90999);
/* harmony import */ var _firebase_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @firebase/util */ 33854);
/* harmony import */ var _firebase_app__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @firebase/app */ 279);
/* harmony import */ var _firebase_logger__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @firebase/logger */ 9306);
/* harmony import */ var _firebase_component__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @firebase/component */ 28604);








/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function _cordovaWindow() {
    return window;
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * How long to wait after the app comes back into focus before concluding that
 * the user closed the sign in tab.
 */
const REDIRECT_TIMEOUT_MS = 2000;
/**
 * Generates the URL for the OAuth handler.
 */
async function _generateHandlerUrl(auth, event, provider) {
    var _a;
    // Get the cordova plugins
    const { BuildInfo } = _cordovaWindow();
    (0,_index_585b6059_js__WEBPACK_IMPORTED_MODULE_0__.ap)(event.sessionId, 'AuthEvent did not contain a session ID');
    const sessionDigest = await computeSha256(event.sessionId);
    const additionalParams = {};
    if ((0,_index_585b6059_js__WEBPACK_IMPORTED_MODULE_0__.aq)()) {
        // iOS app identifier
        additionalParams['ibi'] = BuildInfo.packageName;
    }
    else if ((0,_index_585b6059_js__WEBPACK_IMPORTED_MODULE_0__.ar)()) {
        // Android app identifier
        additionalParams['apn'] = BuildInfo.packageName;
    }
    else {
        (0,_index_585b6059_js__WEBPACK_IMPORTED_MODULE_0__.as)(auth, "operation-not-supported-in-this-environment" /* OPERATION_NOT_SUPPORTED */);
    }
    // Add the display name if available
    if (BuildInfo.displayName) {
        additionalParams['appDisplayName'] = BuildInfo.displayName;
    }
    // Attached the hashed session ID
    additionalParams['sessionId'] = sessionDigest;
    return (0,_index_585b6059_js__WEBPACK_IMPORTED_MODULE_0__.at)(auth, provider, event.type, undefined, (_a = event.eventId) !== null && _a !== void 0 ? _a : undefined, additionalParams);
}
/**
 * Validates that this app is valid for this project configuration
 */
async function _validateOrigin(auth) {
    const { BuildInfo } = _cordovaWindow();
    const request = {};
    if ((0,_index_585b6059_js__WEBPACK_IMPORTED_MODULE_0__.aq)()) {
        request.iosBundleId = BuildInfo.packageName;
    }
    else if ((0,_index_585b6059_js__WEBPACK_IMPORTED_MODULE_0__.ar)()) {
        request.androidPackageName = BuildInfo.packageName;
    }
    else {
        (0,_index_585b6059_js__WEBPACK_IMPORTED_MODULE_0__.as)(auth, "operation-not-supported-in-this-environment" /* OPERATION_NOT_SUPPORTED */);
    }
    // Will fail automatically if package name is not authorized
    await (0,_index_585b6059_js__WEBPACK_IMPORTED_MODULE_0__.au)(auth, request);
}
function _performRedirect(handlerUrl) {
    // Get the cordova plugins
    const { cordova } = _cordovaWindow();
    return new Promise(resolve => {
        cordova.plugins.browsertab.isAvailable(browserTabIsAvailable => {
            let iabRef = null;
            if (browserTabIsAvailable) {
                cordova.plugins.browsertab.openUrl(handlerUrl);
            }
            else {
                // TODO: Return the inappbrowser ref that's returned from the open call
                iabRef = cordova.InAppBrowser.open(handlerUrl, (0,_index_585b6059_js__WEBPACK_IMPORTED_MODULE_0__.ao)() ? '_blank' : '_system', 'location=yes');
            }
            resolve(iabRef);
        });
    });
}
/**
 * This function waits for app activity to be seen before resolving. It does
 * this by attaching listeners to various dom events. Once the app is determined
 * to be visible, this promise resolves. AFTER that resolution, the listeners
 * are detached and any browser tabs left open will be closed.
 */
async function _waitForAppResume(auth, eventListener, iabRef) {
    // Get the cordova plugins
    const { cordova } = _cordovaWindow();
    let cleanup = () => { };
    try {
        await new Promise((resolve, reject) => {
            let onCloseTimer = null;
            // DEFINE ALL THE CALLBACKS =====
            function authEventSeen() {
                var _a;
                // Auth event was detected. Resolve this promise and close the extra
                // window if it's still open.
                resolve();
                const closeBrowserTab = (_a = cordova.plugins.browsertab) === null || _a === void 0 ? void 0 : _a.close;
                if (typeof closeBrowserTab === 'function') {
                    closeBrowserTab();
                }
                // Close inappbrowser emebedded webview in iOS7 and 8 case if still
                // open.
                if (typeof (iabRef === null || iabRef === void 0 ? void 0 : iabRef.close) === 'function') {
                    iabRef.close();
                }
            }
            function resumed() {
                if (onCloseTimer) {
                    // This code already ran; do not rerun.
                    return;
                }
                onCloseTimer = window.setTimeout(() => {
                    // Wait two seeconds after resume then reject.
                    reject((0,_index_585b6059_js__WEBPACK_IMPORTED_MODULE_0__.av)(auth, "redirect-cancelled-by-user" /* REDIRECT_CANCELLED_BY_USER */));
                }, REDIRECT_TIMEOUT_MS);
            }
            function visibilityChanged() {
                if ((document === null || document === void 0 ? void 0 : document.visibilityState) === 'visible') {
                    resumed();
                }
            }
            // ATTACH ALL THE LISTENERS =====
            // Listen for the auth event
            eventListener.addPassiveListener(authEventSeen);
            // Listen for resume and visibility events
            document.addEventListener('resume', resumed, false);
            if ((0,_index_585b6059_js__WEBPACK_IMPORTED_MODULE_0__.ar)()) {
                document.addEventListener('visibilitychange', visibilityChanged, false);
            }
            // SETUP THE CLEANUP FUNCTION =====
            cleanup = () => {
                eventListener.removePassiveListener(authEventSeen);
                document.removeEventListener('resume', resumed, false);
                document.removeEventListener('visibilitychange', visibilityChanged, false);
                if (onCloseTimer) {
                    window.clearTimeout(onCloseTimer);
                }
            };
        });
    }
    finally {
        cleanup();
    }
}
/**
 * Checks the configuration of the Cordova environment. This has no side effect
 * if the configuration is correct; otherwise it throws an error with the
 * missing plugin.
 */
function _checkCordovaConfiguration(auth) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
    const win = _cordovaWindow();
    // Check all dependencies installed.
    // https://github.com/nordnet/cordova-universal-links-plugin
    // Note that cordova-universal-links-plugin has been abandoned.
    // A fork with latest fixes is available at:
    // https://www.npmjs.com/package/cordova-universal-links-plugin-fix
    (0,_index_585b6059_js__WEBPACK_IMPORTED_MODULE_0__.aw)(typeof ((_a = win === null || win === void 0 ? void 0 : win.universalLinks) === null || _a === void 0 ? void 0 : _a.subscribe) === 'function', auth, "invalid-cordova-configuration" /* INVALID_CORDOVA_CONFIGURATION */, {
        missingPlugin: 'cordova-universal-links-plugin-fix'
    });
    // https://www.npmjs.com/package/cordova-plugin-buildinfo
    (0,_index_585b6059_js__WEBPACK_IMPORTED_MODULE_0__.aw)(typeof ((_b = win === null || win === void 0 ? void 0 : win.BuildInfo) === null || _b === void 0 ? void 0 : _b.packageName) !== 'undefined', auth, "invalid-cordova-configuration" /* INVALID_CORDOVA_CONFIGURATION */, {
        missingPlugin: 'cordova-plugin-buildInfo'
    });
    // https://github.com/google/cordova-plugin-browsertab
    (0,_index_585b6059_js__WEBPACK_IMPORTED_MODULE_0__.aw)(typeof ((_e = (_d = (_c = win === null || win === void 0 ? void 0 : win.cordova) === null || _c === void 0 ? void 0 : _c.plugins) === null || _d === void 0 ? void 0 : _d.browsertab) === null || _e === void 0 ? void 0 : _e.openUrl) === 'function', auth, "invalid-cordova-configuration" /* INVALID_CORDOVA_CONFIGURATION */, {
        missingPlugin: 'cordova-plugin-browsertab'
    });
    (0,_index_585b6059_js__WEBPACK_IMPORTED_MODULE_0__.aw)(typeof ((_h = (_g = (_f = win === null || win === void 0 ? void 0 : win.cordova) === null || _f === void 0 ? void 0 : _f.plugins) === null || _g === void 0 ? void 0 : _g.browsertab) === null || _h === void 0 ? void 0 : _h.isAvailable) === 'function', auth, "invalid-cordova-configuration" /* INVALID_CORDOVA_CONFIGURATION */, {
        missingPlugin: 'cordova-plugin-browsertab'
    });
    // https://cordova.apache.org/docs/en/latest/reference/cordova-plugin-inappbrowser/
    (0,_index_585b6059_js__WEBPACK_IMPORTED_MODULE_0__.aw)(typeof ((_k = (_j = win === null || win === void 0 ? void 0 : win.cordova) === null || _j === void 0 ? void 0 : _j.InAppBrowser) === null || _k === void 0 ? void 0 : _k.open) === 'function', auth, "invalid-cordova-configuration" /* INVALID_CORDOVA_CONFIGURATION */, {
        missingPlugin: 'cordova-plugin-inappbrowser'
    });
}
/**
 * Computes the SHA-256 of a session ID. The SubtleCrypto interface is only
 * available in "secure" contexts, which covers Cordova (which is served on a file
 * protocol).
 */
async function computeSha256(sessionId) {
    const bytes = stringToArrayBuffer(sessionId);
    // TODO: For IE11 crypto has a different name and this operation comes back
    //       as an object, not a promise. This is the old proposed standard that
    //       is used by IE11:
    // https://www.w3.org/TR/2013/WD-WebCryptoAPI-20130108/#cryptooperation-interface
    const buf = await crypto.subtle.digest('SHA-256', bytes);
    const arr = Array.from(new Uint8Array(buf));
    return arr.map(num => num.toString(16).padStart(2, '0')).join('');
}
function stringToArrayBuffer(str) {
    // This function is only meant to deal with an ASCII charset and makes
    // certain simplifying assumptions.
    (0,_index_585b6059_js__WEBPACK_IMPORTED_MODULE_0__.ap)(/[0-9a-zA-Z]+/.test(str), 'Can only convert alpha-numeric strings');
    if (typeof TextEncoder !== 'undefined') {
        return new TextEncoder().encode(str);
    }
    const buff = new ArrayBuffer(str.length);
    const view = new Uint8Array(buff);
    for (let i = 0; i < str.length; i++) {
        view[i] = str.charCodeAt(i);
    }
    return view;
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const SESSION_ID_LENGTH = 20;
/** Custom AuthEventManager that adds passive listeners to events */
class CordovaAuthEventManager extends _index_585b6059_js__WEBPACK_IMPORTED_MODULE_0__.az {
    constructor() {
        super(...arguments);
        this.passiveListeners = new Set();
        this.initPromise = new Promise(resolve => {
            this.resolveInialized = resolve;
        });
    }
    addPassiveListener(cb) {
        this.passiveListeners.add(cb);
    }
    removePassiveListener(cb) {
        this.passiveListeners.delete(cb);
    }
    // In a Cordova environment, this manager can live through multiple redirect
    // operations
    resetRedirect() {
        this.queuedRedirectEvent = null;
        this.hasHandledPotentialRedirect = false;
    }
    /** Override the onEvent method */
    onEvent(event) {
        this.resolveInialized();
        this.passiveListeners.forEach(cb => cb(event));
        return super.onEvent(event);
    }
    async initialized() {
        await this.initPromise;
    }
}
/**
 * Generates a (partial) {@link AuthEvent}.
 */
function _generateNewEvent(auth, type, eventId = null) {
    return {
        type,
        eventId,
        urlResponse: null,
        sessionId: generateSessionId(),
        postBody: null,
        tenantId: auth.tenantId,
        error: (0,_index_585b6059_js__WEBPACK_IMPORTED_MODULE_0__.av)(auth, "no-auth-event" /* NO_AUTH_EVENT */)
    };
}
function _savePartialEvent(auth, event) {
    return storage()._set(persistenceKey(auth), event);
}
async function _getAndRemoveEvent(auth) {
    const event = (await storage()._get(persistenceKey(auth)));
    if (event) {
        await storage()._remove(persistenceKey(auth));
    }
    return event;
}
function _eventFromPartialAndUrl(partialEvent, url) {
    var _a, _b;
    // Parse the deep link within the dynamic link URL.
    const callbackUrl = _getDeepLinkFromCallback(url);
    // Confirm it is actually a callback URL.
    // Currently the universal link will be of this format:
    // https://<AUTH_DOMAIN>/__/auth/callback<OAUTH_RESPONSE>
    // This is a fake URL but is not intended to take the user anywhere
    // and just redirect to the app.
    if (callbackUrl.includes('/__/auth/callback')) {
        // Check if there is an error in the URL.
        // This mechanism is also used to pass errors back to the app:
        // https://<AUTH_DOMAIN>/__/auth/callback?firebaseError=<STRINGIFIED_ERROR>
        const params = searchParamsOrEmpty(callbackUrl);
        // Get the error object corresponding to the stringified error if found.
        const errorObject = params['firebaseError']
            ? parseJsonOrNull(decodeURIComponent(params['firebaseError']))
            : null;
        const code = (_b = (_a = errorObject === null || errorObject === void 0 ? void 0 : errorObject['code']) === null || _a === void 0 ? void 0 : _a.split('auth/')) === null || _b === void 0 ? void 0 : _b[1];
        const error = code ? (0,_index_585b6059_js__WEBPACK_IMPORTED_MODULE_0__.av)(code) : null;
        if (error) {
            return {
                type: partialEvent.type,
                eventId: partialEvent.eventId,
                tenantId: partialEvent.tenantId,
                error,
                urlResponse: null,
                sessionId: null,
                postBody: null
            };
        }
        else {
            return {
                type: partialEvent.type,
                eventId: partialEvent.eventId,
                tenantId: partialEvent.tenantId,
                sessionId: partialEvent.sessionId,
                urlResponse: callbackUrl,
                postBody: null
            };
        }
    }
    return null;
}
function generateSessionId() {
    const chars = [];
    const allowedChars = '1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';
    for (let i = 0; i < SESSION_ID_LENGTH; i++) {
        const idx = Math.floor(Math.random() * allowedChars.length);
        chars.push(allowedChars.charAt(idx));
    }
    return chars.join('');
}
function storage() {
    return (0,_index_585b6059_js__WEBPACK_IMPORTED_MODULE_0__.ax)(_index_585b6059_js__WEBPACK_IMPORTED_MODULE_0__.b);
}
function persistenceKey(auth) {
    return (0,_index_585b6059_js__WEBPACK_IMPORTED_MODULE_0__.ay)("authEvent" /* AUTH_EVENT */, auth.config.apiKey, auth.name);
}
function parseJsonOrNull(json) {
    try {
        return JSON.parse(json);
    }
    catch (e) {
        return null;
    }
}
// Exported for testing
function _getDeepLinkFromCallback(url) {
    const params = searchParamsOrEmpty(url);
    const link = params['link'] ? decodeURIComponent(params['link']) : undefined;
    // Double link case (automatic redirect)
    const doubleDeepLink = searchParamsOrEmpty(link)['link'];
    // iOS custom scheme links.
    const iOSDeepLink = params['deep_link_id']
        ? decodeURIComponent(params['deep_link_id'])
        : undefined;
    const iOSDoubleDeepLink = searchParamsOrEmpty(iOSDeepLink)['link'];
    return iOSDoubleDeepLink || iOSDeepLink || doubleDeepLink || link || url;
}
/**
 * Optimistically tries to get search params from a string, or else returns an
 * empty search params object.
 */
function searchParamsOrEmpty(url) {
    if (!(url === null || url === void 0 ? void 0 : url.includes('?'))) {
        return {};
    }
    const [_, ...rest] = url.split('?');
    return (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.querystringDecode)(rest.join('?'));
}

/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * How long to wait for the initial auth event before concluding no
 * redirect pending
 */
const INITIAL_EVENT_TIMEOUT_MS = 500;
class CordovaPopupRedirectResolver {
    constructor() {
        this._redirectPersistence = _index_585b6059_js__WEBPACK_IMPORTED_MODULE_0__.a;
        this._shouldInitProactively = true; // This is lightweight for Cordova
        this.eventManagers = new Map();
        this.originValidationPromises = {};
        this._completeRedirectFn = _index_585b6059_js__WEBPACK_IMPORTED_MODULE_0__.aA;
    }
    async _initialize(auth) {
        const key = auth._key();
        let manager = this.eventManagers.get(key);
        if (!manager) {
            manager = new CordovaAuthEventManager(auth);
            this.eventManagers.set(key, manager);
            this.attachCallbackListeners(auth, manager);
        }
        return manager;
    }
    _openPopup(auth) {
        (0,_index_585b6059_js__WEBPACK_IMPORTED_MODULE_0__.as)(auth, "operation-not-supported-in-this-environment" /* OPERATION_NOT_SUPPORTED */);
    }
    async _openRedirect(auth, provider, authType, eventId) {
        _checkCordovaConfiguration(auth);
        const manager = await this._initialize(auth);
        await manager.initialized();
        // Reset the persisted redirect states. This does not matter on Web where
        // the redirect always blows away application state entirely. On Cordova,
        // the app maintains control flow through the redirect.
        manager.resetRedirect();
        (0,_index_585b6059_js__WEBPACK_IMPORTED_MODULE_0__.aB)();
        await this._originValidation(auth);
        const event = _generateNewEvent(auth, authType, eventId);
        await _savePartialEvent(auth, event);
        const url = await _generateHandlerUrl(auth, event, provider);
        const iabRef = await _performRedirect(url);
        return _waitForAppResume(auth, manager, iabRef);
    }
    _isIframeWebStorageSupported(_auth, _cb) {
        throw new Error('Method not implemented.');
    }
    _originValidation(auth) {
        const key = auth._key();
        if (!this.originValidationPromises[key]) {
            this.originValidationPromises[key] = _validateOrigin(auth);
        }
        return this.originValidationPromises[key];
    }
    attachCallbackListeners(auth, manager) {
        // Get the global plugins
        const { universalLinks, handleOpenURL, BuildInfo } = _cordovaWindow();
        const noEventTimeout = setTimeout(async () => {
            // We didn't see that initial event. Clear any pending object and
            // dispatch no event
            await _getAndRemoveEvent(auth);
            manager.onEvent(generateNoEvent());
        }, INITIAL_EVENT_TIMEOUT_MS);
        const universalLinksCb = async (eventData) => {
            // We have an event so we can clear the no event timeout
            clearTimeout(noEventTimeout);
            const partialEvent = await _getAndRemoveEvent(auth);
            let finalEvent = null;
            if (partialEvent && (eventData === null || eventData === void 0 ? void 0 : eventData['url'])) {
                finalEvent = _eventFromPartialAndUrl(partialEvent, eventData['url']);
            }
            // If finalEvent is never filled, trigger with no event
            manager.onEvent(finalEvent || generateNoEvent());
        };
        // Universal links subscriber doesn't exist for iOS, so we need to check
        if (typeof universalLinks !== 'undefined' &&
            typeof universalLinks.subscribe === 'function') {
            universalLinks.subscribe(null, universalLinksCb);
        }
        // iOS 7 or 8 custom URL schemes.
        // This is also the current default behavior for iOS 9+.
        // For this to work, cordova-plugin-customurlscheme needs to be installed.
        // https://github.com/EddyVerbruggen/Custom-URL-scheme
        // Do not overwrite the existing developer's URL handler.
        const existingHandleOpenURL = handleOpenURL;
        const packagePrefix = `${BuildInfo.packageName.toLowerCase()}://`;
        _cordovaWindow().handleOpenURL = async (url) => {
            if (url.toLowerCase().startsWith(packagePrefix)) {
                // We want this intentionally to float
                // eslint-disable-next-line @typescript-eslint/no-floating-promises
                universalLinksCb({ url });
            }
            // Call the developer's handler if it is present.
            if (typeof existingHandleOpenURL === 'function') {
                try {
                    existingHandleOpenURL(url);
                }
                catch (e) {
                    // This is a developer error. Don't stop the flow of the SDK.
                    console.error(e);
                }
            }
        };
    }
}
/**
 * An implementation of {@link PopupRedirectResolver} suitable for Cordova
 * based applications.
 *
 * @public
 */
const cordovaPopupRedirectResolver = CordovaPopupRedirectResolver;
function generateNoEvent() {
    return {
        type: "unknown" /* UNKNOWN */,
        eventId: null,
        sessionId: null,
        urlResponse: null,
        postBody: null,
        tenantId: null,
        error: (0,_index_585b6059_js__WEBPACK_IMPORTED_MODULE_0__.av)("no-auth-event" /* NO_AUTH_EVENT */)
    };
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// This function should only be called by frameworks (e.g. FirebaseUI-web) to log their usage.
// It is not intended for direct use by developer apps. NO jsdoc here to intentionally leave it out
// of autogenerated documentation pages to reduce accidental misuse.
function addFrameworkForLogging(auth, framework) {
    (0,_index_585b6059_js__WEBPACK_IMPORTED_MODULE_0__.aC)(auth)._logFramework(framework);
}


//# sourceMappingURL=internal.js.map


/***/ }),

/***/ 36412:
/*!*************************************************************!*\
  !*** ./node_modules/firebase/compat/auth/dist/index.esm.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _firebase_auth_compat__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @firebase/auth-compat */ 1623);

//# sourceMappingURL=index.esm.js.map


/***/ })

}]);
//# sourceMappingURL=node_modules_firebase_compat_auth_dist_index_esm_js.js.map